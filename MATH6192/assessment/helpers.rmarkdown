---
title: Helpers
format: html
---



## Initial setup




```{r}
library(tidyverse)
```


## Some Generic Helpers

### Affine Transformations



```{r}
# Wrapper over any target density function
# affine density of z = ax + b
# This function would return a new function d(z)
daffine <- function(d, a, b,...) {
  \(z) (1 / abs(a)) * d((z - b) / a, ...) 
}
# function would return a new r(z) the would be sample from the z space where x
# is a well-known distribution
raffine <- function(r, a, b, ...) {
  par <- list(...)
  \(n) a * do.call(r, c(list(n = n), par)) + b
}
# Example usage
dz <- daffine(dnorm , a = 2, b = 3, mean = 0, sd = 1)
rz <- raffine(rnorm, a = 2, b = 3, mean = 0, sd = 1)
dz(3)
dnorm(3,3,2)
z <- rz(1e5)
mean(z);sd(z)

```


### Density plots



```{r}
params <- tribble(
  ~shape1, ~shape2,
  1,1,
  1,2,
  1,1.5,
  2,2.5
)
# pass params in a list or a tibble 
plot_density <- function(dfunc, params) {
  plt <- ggplot()
  reduce(
  pmap(params, \(...) {
      par <- list(...)
      lbl <- do.call(paste, c(...,list(sep = ",")))
      geom_function(
        aes(colour = lbl),
        fun = \(x) do.call(dfunc, c(list(x = x), par))
      )
    }
  ),
    `+`,
    .init = plt
  ) +
    labs(color = "Parameters", x = "x", y = "density", title = "Densities for various parameter combinations") + theme_minimal()
}
plot_density(dbeta, params)

```



## Rejection Sampling

### Rejection Sampling function


```{r}
# Generic Rejection Sampling function
# using log transformation for numeric stability
# pass any additional parameters for the proposal distribution in the the parameters after n
sample_reject <- function(dtgt, 
                          dprop, # defaulted to uniform
                          rprop, # defaulted to uniform
                          support = c(0,1), 
                          n,
                          scaling_const = NA
                          ) {
                          # ...) {
  log_ratio <- function(x) log(dtgt(x)) - log(dprop(x,...))

  # Sampled value
  X <- numeric(n)
  total_run <- 0
  accepted <- 0
 
  if (is.na(scaling_const)) {
    opt <- optimise(log_ratio, support, maximum = T)
    logM <- opt$objective
  } else {
    logM <- log(scaling_const)
  }
  
  if (!is.finite(logM)) stop("M is not finite; dtgt/dprop may be unbounded on the support")

  while (accepted < n) {
    # sampling from proposal dist
    z <- rprop(1)
    # z <- rprop(1,...)
    # total_run should be immediately updated after a random draw
    total_run <- total_run + 1
    if (z < support[1] || z > support[2]) next

    log_rz <- log_ratio(z)
    if (!is.finite(log_rz)) next

    log_p_qm <- log_rz - logM
    p_qm <- exp(log_p_qm) 
    if (p_qm > 1) p_qm <- 1

    if (runif(1) <= p_qm) {
      accepted <- accepted + 1
      X[accepted] <- z
    }
  }

  list(
    X = X,
    total_run = total_run,
    accept_rate = n / total_run,
    M = exp(logM)
  )
}
```


## Metropolis - Hastings (MCMC)

# calculating on the log scale



```{r}
log_post <- function(z, data = saints_goals) {
  # likelihood <- sapply(z, prod(dpois(data, exp(z)) ) ) 
  log_lkld <- sapply(z, 
    function(z) sum(dpois(data, exp(z), log = T))  
  ) 
  log_lkld + dnorm(z, 1, 0.5, log = T)
}
```

```{r}
log_ratio <- function(z1, z2) {
  log_post(z1) - log_post(z2)
}
metropolis <- function(start_val = 1, 
                       n = 1000, 
                       rprop = rnorm, 
                       log_ratio,
                       prev_val_param = "mean",
                       ...) {
    z <- c(log(start_val), rep(0, n)) # start_val would be rejected at the end
    accept <- 0
      for (i in 2:(n+1)) {
        prop <- do.call(
           rprop, 
           c(
           list(n = 1), 
           setNames(list(z[i - 1]), prev_val_param), 
           list(...)
           )
         )
        if (log(runif(1)) < min(0, log_ratio(prop, z[i - 1])) ) {
          z[i] <- prop
          accept <- accept + 1
        } else {
          z[i] <- z[i - 1]
        }
      }
    list(sample = exp(z[2:(n+1)]), accept_rate = accept / n)
}
```


## Importance Sampling



```{r}
expected_importance <- function(tgt_func, dtgt, dprop, rprop, n) {
  x <- rprop(n)
  f_x <- tgt_func(x)
  w <- dtgt(x) / dprop(x)

  # normalised IS
  sum(f_x * w) / sum(w)
} 
```

