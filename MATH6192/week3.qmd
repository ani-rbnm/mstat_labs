#### Initialisation


```{r}
library(tidyverse)
set.seed(42)
```

#### Task 1


```{r}

set.seed(42)
get_r_walk <- function(n = 1000, mean = 0, sd = 1) {
  y <- numeric(n)
  y <- 0 # initialising
  
  for (i in 2:n) {
    y[i] <- y[i - 1] + rnorm(1, mean = mean, sd = sd)
  }
  y
}

n <- 100
y <- get_r_walk(n, mean = 0, sd = 0.1)

cv <- sd(y)/mean(y)
cv
ggplot() +
  geom_line(aes(x = 1:n, y = y)) +
  labs(x = "Time", y = expression(y[t])) +
  theme_minimal()
```

#### Task 2

```{r}
get_un_loglin <- function(theta, mu = 0, sigma = 1, y) {
  un_dist <- theta^(sum(y) - 1) * exp(-length(y) * theta) *
    exp(-((log(theta) - mu) ^ 2) / (2 * sigma ^ 2))

  un_dist
}


```


```{r}
saints_goals <- c(1, 2, 2, 0, 2, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 3, 0, 1, 0, 3, 0, 1, 3, 0, 1, 4)

```


```{r}
S <- sum(saints_goals)
eta_prime <- log(0.8)
eta <- log(1.1)
n <- length(saints_goals)
mu <- 1
sigma <- 0.5

lr <- S * (eta_prime - eta) - n * (exp(eta_prime) - exp(eta)) - 
  ((eta_prime - mu) ^ 2 - (eta - mu) ^ 2)/(2 * sigma^2)

ar <- exp(lr)
ar
```

MCMC

```{r}
set.seed(42)
## Log unnormalised posterior for eta = log(theta)
## y    : vector of Poisson observations
## mu   : prior mean for eta
## sigma: prior sd for eta
logpost_eta <- function(eta, y, mu, sigma) {
  S <- sum(y)
  n <- length(y)
  # lp = S*eta - n*exp(eta) - (eta - mu)^2 / (2*sigma^2)
  S * eta - n * exp(eta) - (eta - mu)^2 / (2 * sigma^2)
}

## Metropolis sampler on eta = log(theta)
## proposal: eta' ~ N(eta_t, proposal_sd^2)
mh_pois_lognorm <- function(y,
                            mu,
                            sigma,
                            n_iter      = 10000,
                            proposal_sd = 0.2,  # 0.2^2 = 0.04
                            eta_init    = NULL) {
  if (is.null(eta_init)) {
    # Simple default: log of (mean(y)+small_offset) to avoid log(0)
    eta_init <- log(mean(y) + 0.1)
  }
  
  eta <- numeric(n_iter)
  eta[1] <- eta_init
  
  lp_curr <- logpost_eta(eta[1], y, mu, sigma)
  n_accept <- 0L
  
  for (t in 2:n_iter) {
    # Propose new eta'
    eta_prop <- rnorm(1, mean = eta[t - 1], sd = proposal_sd)
    
    # Log unnormalised posterior at proposal
    lp_prop <- logpost_eta(eta_prop, y, mu, sigma)
    
    # Log acceptance ratio
    log_r <- lp_prop - lp_curr
    
    # Accept/reject
    if (log(runif(1)) < log_r) {
      eta[t]   <- eta_prop
      lp_curr  <- lp_prop
      n_accept <- n_accept + 1L
    } else {
      eta[t] <- eta[t - 1]  # stay put
    }
  }
  
  theta <- exp(eta)
  
  list(
    eta         = eta,
    theta       = theta,
    accept_rate = n_accept / (n_iter - 1),
    mu          = mu,
    sigma       = sigma,
    proposal_sd = proposal_sd
  )
}
 
resp <- mh_pois_lognorm(y = saints_goals,
  mu = 1,
  sigma = 0.5,
  n_iter = 100,
  proposal_sd = 0.2,
    eta_init = mean(saints_goals)
  )
resp$theta
mean( resp$theta )
resp$accept_rate
```
From solution


```{r}
set.seed(42)

post <- function(theta, data = saints_goals) {

 likelihood <- sapply(theta, \(x) prod(dpois(data, x)))

 likelihood * dnorm(log(theta), 1, 0.5)
}

ratio <- function(theta1, theta2) post(theta1) / post(theta2)
metropolis <- function(start_val = 1, n = 1000, sd = 0.2) {

 theta <- c(start_val, rep(0, n))

 accept <- 0

 for(i in 2:(n + 1)) {

 prop <- exp(rnorm(1, log(theta[i - 1]), sd))

 if(ratio(prop, theta[i - 1]) > runif(1)) {

  theta[i] <- prop

  accept <- accept + 1

 } else theta[i] <- theta[i - 1]

 }

 return(list(sample = theta[2:(n + 1)], accept_rate = accept / n))

}

thetahat <- mean(saints_goals)

theta <- metropolis(start_val = thetahat, n = 100)
theta$sample
mean(theta$sample)
```

Dear Professor,

Many thanks for posting the quiz solutions. I have a couple of queries:

1. In the following line, it seems to me that we are only partially converting prior $\theta$ to the log scale, 
and it seems the jacobian adjustment of $1/\theta$ is missing.

 `likelihood * dnorm(log(theta), 1, 0.5)`

2. Following on from the previous point, since `theta1` and `theta2` are not on the log scale, can we assume that the proposal is 
truly symmetric? Therefore, should we be calculating the acceptance ratio in the following way without accounting for the proposal ratios?

`ratio <- function(theta1, theta2) post(theta1) / post(theta2)`

My understanding is that Acceptance ratio, `r` should be,
$$
r = \frac {\exp {\left[ \eta^*\sum x_i -n e^{\eta^*}  -(\eta^* - \mu)^2/2 \sigma^2 \right]}} {\exp {\left[ \eta^{t-1}\sum x_i -n e^{\eta^{t-1}}  -(\eta^{t-1} - \mu)^2/2 \sigma^2 \right]}} 
$$
where $\eta = \log{\theta}$

This uses lognormal distribution for the prior $\theta$ and then transforms the whole posterior from $\theta$ to $\eta$. I proceeded in this manner sampling from gaussian proposal,
getting a log posterior vector which I then exponentiated at the very end to get the true posterior.

Please correct me if I am wrong.


